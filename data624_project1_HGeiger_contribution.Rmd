---
title: "Data 624, Project 1, Group 1: Exploration and forecasting of select series"
author: "Heather Geiger"
output: 
 html_document:
  code_folding: hide
  smart: false
---

# Introduction

From the assignment instructions:

"Your data is a de-identified Excel spreadsheet.  Your assignment is to perform the appropriate analysis to forecast several series for 140 periods.  You will have 1622 periods for your analysis."

I saved the Excel spreadsheet in a CSV file, and will be using this for all analysis.

We also divided the work so that each group member would analyze three series. My assigned series are S02, S03, and S04. Full forecast list:

* S02 – Forecast  Var02, Var03
* S03 – Forecast  Var05, Var07
* S04 – Forecast  Var01, Var02

# Libraries

Load in relevant libraries, including tidyverse and the forecasting library fpp2.

Also lubridate for easier handling of dates.

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(tidyr)
library(dplyr)
library(fpp2)
library(lubridate)
```

# Data exploration

## Read in and format data.

Read in the data from the CSV file.

```{r}
data <- read.csv("data624_project1_excel_sheet_as_csv.csv",
	header=TRUE,stringsAsFactors=FALSE)
```

Convert SeriesInd from Excel date number format to regular R dates.

```{r}
data$SeriesInd <- as.Date(data$SeriesInd,origin = "1899-12-30")
```

Separate the lines with actual data (1622 x 6 series = 9732) from the lines that are empty, but just give the dates over which we should forecast.

```{r}
dates_to_forecast <- unique(data$SeriesInd[9733:nrow(data)])

data <- data[1:9732,]
```

## Check which dates included in SeriesInd and dates to be forecast.

First, let's get a general overview by seeing how many of each day of the week included.

```{r}
table(weekdays(unique(data$SeriesInd)))
```

Looks like Wednesdays and Thursdays are not included at all. What about other dates missing from SeriesInd?

```{r}
data_range <- as.Date(seq(from=min(data$SeriesInd),to=max(data$SeriesInd),by="days"),origin="1970-01-01")

missing_dates <- as.Date(setdiff(data_range,unique(data$SeriesInd)),origin="1970-01-01")

missing_dates <- missing_dates[weekdays(missing_dates) %in% c("Monday","Tuesday","Friday","Saturday","Sunday")]

missing_dates <- missing_dates[order(lubridate::month(missing_dates),day(missing_dates))]

data.frame(Day = weekdays(missing_dates),
	Date = missing_dates)
```

We get the following list of holidays.

* First Friday of January
* One time holiday in 2014 on Friday 02/28/14 and Saturday 03/01/14.
* Last Monday in March
* Late April, exact date varies (has been April 24 to 26 so far)
* Early May, exact date varies (has been May 2 or 3 so far)
* One Friday a month (toward the middle or end of the month) every year in May, June, and September
* One Tuesday a year from late July to late August
* Early November, exact date varies (has been November 1 to 4 so far)

Now, what range of dates are we being asked to forecast? And does this include any holidays?

```{r, echo=FALSE}
print("Date range to forecast, and weekdays of forecast dates:")
```

```{r}
range(dates_to_forecast)
table(weekdays(dates_to_forecast))
```

```{r, echo=FALSE}
print("Dates missing from to be forecast:")
```

```{r}
forecast_range <- as.Date(seq(from=min(dates_to_forecast),to=max(dates_to_forecast),by="days"),origin="1970-01-01")

missing_dates <- as.Date(setdiff(forecast_range,dates_to_forecast),origin="1970-01-01")

missing_dates <- missing_dates[weekdays(missing_dates) %in% c("Monday","Tuesday","Friday","Saturday","Sunday")]

missing_dates <- missing_dates[order(lubridate::month(missing_dates),day(missing_dates))]

data.frame(Day = weekdays(missing_dates),
        Date = missing_dates)
```

Looks like we are not being asked to forecast for Wednesdays or Thursdays, nor on any holidays. So that's good.

## Check for missing values.

In addition to dates missing from SeriesInd, there may be data missing for only certain series. Let's check.

```{r}
data_gathered <- gather(data,
	key="Variable",
	value="Value",
	-SeriesInd,-group)
data_gathered <- data.frame(data_gathered,
	Group.plus.var = paste0(data_gathered$group,"-",data_gathered$Variable),
	stringsAsFactors=FALSE)
data_gathered <- data_gathered[order(data_gathered$SeriesInd,data_gathered$group),]

dates_with_NA <- as.Date(c(40697,41821,42897,42898,42997,43000),origin="1899-12-30")

data_gathered[which(is.na(data_gathered$Value) == TRUE & (data_gathered$SeriesInd == dates_with_NA[1] | data_gathered$SeriesInd == dates_with_NA[2])),]
data_gathered[which(is.na(data_gathered$Value) == TRUE & (data_gathered$SeriesInd == dates_with_NA[3] | data_gathered$SeriesInd == dates_with_NA[4])),]
data_gathered[which(is.na(data_gathered$Value) == TRUE & (data_gathered$SeriesInd == dates_with_NA[5] | data_gathered$SeriesInd == dates_with_NA[6])),]
```

```{r, echo=FALSE}
print("Day of week of 2017-06-11:")
```

```{r}
weekdays(as.Date("2017-06-11",origin="1970-01-01"))
```

```{r, echo=FALSE}
print("Day of week of 2017-09-19 and 2017-09-22:")
```

```{r}
weekdays(as.Date(c("2017-09-19","2017-09-22"),origin="1970-01-01"))
``` 

We find the following missing values.

* Date 2011-06-03, all five variables of S06. Simply remove or use the nearby timepoints within the same series and variable to fill in.
* Date 2014-07-01, all five variables of S05. Simply remove or use the nearby timepoints within the same series and variable to fill in.
* Dates 2017-06-11 (Sunday) and 2017-06-12 (Monday), all six series and all four correlated variables (1/3/5/7). Simply remove or use the nearby timepoints within the same series and variable to fill in.
* Dates 2017-09-19 and 2017-09-22, all six series and 3/4 correlated variables (3/5/7). Can either use nearby timepoints or the correlated variable without missing values (Var01).

Relevant to this part of the project are the last four dates only.

Let's move on to do some more data exploration. That will help us decide how we should fill in missing dates and NAs.

# Data exploration - initial

Start with some simple line plots across the full range of time.

Remember, we are interested in the following:

* S02 – Forecast  Var02, Var03
* S03 – Forecast  Var05, Var07
* S04 – Forecast  Var01, Var02

```{r}
data_gathered_full <- data_gathered
data_gathered <- data_gathered[data_gathered$Group.plus.var %in% c("S02-Var02","S02-Var03","S03-Var05","S03-Var07","S04-Var01","S04-Var02"),]
```

```{r,fig.height=6,fig.width=10}
ggplot(data_gathered,
aes(SeriesInd,Value)) +
geom_line() +
facet_wrap(~Group.plus.var,ncol=3,nrow=2,scales="free") +
xlab("Time")
```

Remove a few outliers and replot.

```{r}
outliers <- which(data_gathered$Group.plus.var == "S02-Var02" & data_gathered$Value > 3e8)
outliers <- c(outliers, which(data_gathered$Group.plus.var == "S02-Var03" & data_gathered$Value > 20))
outliers <- c(outliers,which(data_gathered$Group.plus.var == "S04-Var02" & data_gathered$Value > 1e8))

data_gathered_minus_outliers <- data_gathered[setdiff(1:nrow(data_gathered),outliers),]
```

```{r,fig.height=6,fig.width=10}
ggplot(data_gathered_minus_outliers,
aes(SeriesInd,Value)) +
geom_line() +
facet_wrap(~Group.plus.var,ncol=3,nrow=2,scales="free") +
xlab("Time") +
ggtitle("Minus outliers")
```

Some notes:

* Var02 (in both groups) is definitely noisier than the other variables.
* S04-Var02 looks like a stationary series. S02-Var02 may or may not be, hard to tell. Kind of looks like it could be, though also sort of looks like could have a bit of a decreasing trend.
* The other variables seems like they have some kind of pattern to them. Although it looks like it could be cyclic rather than a trend, in which case modeling as a stationary series could still work.
* The non-Var02 variables may also have a seasonal component, but it is a bit hard to tell from this graph alone.

One quick thing to check - is there any day of the week pattern? Let's plot to check.

```{r,fig.width=6,fig.height=6}
data_gathered_minus_outliers <- data.frame(data_gathered_minus_outliers,
	Day = weekdays(data_gathered_minus_outliers$SeriesInd),
	stringsAsFactors=FALSE)

mycol <- c("#000000", "#009E73", "#e79f00", "#9ad0f3", "#0072B2", "#D55E00", "#CC79A7", "#F0E442") #Colorblind-friendly vector
mycol <- mycol[c(2:8,1)]

ggplot(data_gathered_minus_outliers[data_gathered_minus_outliers$Variable != "Var02",],
aes(SeriesInd,Value,colour=Day)) +
geom_line() +
facet_wrap(~Group.plus.var,ncol=2,nrow=2,scales="free") +
xlab("Time") +
ggtitle("Minus outliers") +
scale_colour_manual(values=mycol) +
theme(legend.position=c(0.65,0.3))
```

```{r,fig.height=6,fig.width=10}
ggplot(data_gathered_minus_outliers[data_gathered_minus_outliers$Group.plus.var == "S02-Var02",],
aes(SeriesInd,Value)) +
geom_line() +
facet_wrap(~Day,ncol=3,nrow=2) +
xlab("Time") +
ggtitle("S02-Var02, minus outliers")
```

```{r,fig.height=6,fig.width=10}
ggplot(data_gathered_minus_outliers[data_gathered_minus_outliers$Group.plus.var == "S02-Var02",],
aes(SeriesInd,Value)) +
geom_line() +
facet_wrap(~Day,ncol=3,nrow=2) +
xlab("Time") +
ggtitle("S02-Var02, minus outliers, reduce ylim") +
coord_cartesian(ylim=c(0,2e8))
```

```{r, fig.height=6,fig.width=10}
ggplot(data_gathered_minus_outliers[data_gathered_minus_outliers$Group.plus.var == "S04-Var02",],
aes(SeriesInd,Value)) +
geom_line() +
facet_wrap(~Day,ncol=3,nrow=2) +
xlab("Time") +
ggtitle("S04-Var02, minus outliers") 
```

```{r, fig.height=6,fig.width=10}
ggplot(data_gathered_minus_outliers[data_gathered_minus_outliers$Group.plus.var == "S04-Var02",],
aes(SeriesInd,Value)) +
geom_line() +
facet_wrap(~Day,ncol=3,nrow=2) +
xlab("Time") +
ggtitle("S04-Var02, minus outliers, reduce ylim") +
coord_cartesian(ylim=c(0,5e7))
```

There does not seem to be a major day of the week component in any of the variables we are working with.

Next, let's get the average values per month, and create a time series from these, for each variable.

Then, plot decomposition.

```{r}
data_gathered <- data.frame(data_gathered,
	Month = lubridate::month(data_gathered$SeriesInd),
	Quarter = quarters(data_gathered$SeriesInd),
	Year = format(data_gathered$SeriesInd,"%Y"),
	stringsAsFactors=FALSE)

average_per_month <- aggregate(Value ~ Month + Year + Group.plus.var,data=data_gathered,FUN=mean)
```

```{r}
average_per_month <- data.frame(average_per_month,
	Date = as.Date(paste0(average_per_month$Year,"-",average_per_month$Month,"-01"),origin="1970-01-01"),
	stringsAsFactors=FALSE)

average_per_month <- average_per_month[order(average_per_month$Date),]
```

```{r}
for(var in unique(average_per_month$Group.plus.var)[order(unique(average_per_month$Group.plus.var))])
{
this_var_monthly_averages <- average_per_month[average_per_month$Group.plus.var == var,]
this_var_monthly_ts <- ts(data=this_var_monthly_averages$Value,
	start = c(2011,5),
	deltat = 1/12)
monthly_decomp <- this_var_monthly_ts %>% stl(s.window="periodic")
print(autoplot(monthly_decomp) + ggtitle(paste0(var,", monthly averages")))
print(ggsubseriesplot(this_var_monthly_ts) + ggtitle(paste0(var,", monthly averages")))
}
```

These plots are very informative!

The decreasing trend in S02-Var02 is very apparent on this plot.

We also find an interesting seasonal pattern where the value peaks in May. Then decreases until around Dec-Jan, increases a bit Feb-March, and dips substantially in April.

Moving on to S02-Var03, the cyclic pattern we thought we might have seen before is a lot clearer now.

We see that June is lower than the surrounding months (May and July). Otherwise, highest values are around April-May and July-August.

S03-Var05 and S03-Var07 also seem to have a cyclic pattern. These variables show a yearly trough in May and June (especially May).

S04-Var01 may have a cylic pattern, but the second peak would be beyond the scope of the data. So we'll have to treat as non-cyclic to avoid over-extrapolating.

Like the S03 variables, S04-Var01 also shows a bit of a May-June trough. Then increases a bit July-Sept, decreases Oct-Jan, and increases Feb-Apr.

S04-Var02 seems like it may have a cyclic pattern as well. In the seasonal component, there is a strong peak in January.

# Data cleaning

## Dealing with missing dates in SeriesInd and variable NAs

To review, this is the list of holidays:

* First Friday of January
* One time holiday in 2014 on Friday 02/28/14 and Saturday 03/01/14.
* Last Monday in March
* Late April, exact date varies (has been April 24 to 26 so far)
* Early May, exact date varies (has been May 2 or 3 so far)
* One Friday a month (toward the middle or end of the month) every year in May, June, and September
* One Tuesday a year from late July to late August
* Early November, exact date varies (has been November 1 to 4 so far)

And additional missing dates for at least one of our variables are:

* Dates 2017-06-11 (Sunday) and 2017-06-12 (Monday)
* Dates 2017-09-19 (Tuesday) and 2017-09-22 (Friday)

Let's just keep this simple and average the nearest non-missing day before and day after for all of these.

```{r}
data_range <- as.Date(seq(from=min(data$SeriesInd),to=max(data$SeriesInd),by="days"),origin="1970-01-01")

missing_dates <- as.Date(setdiff(data_range,unique(data$SeriesInd)),origin="1970-01-01")

missing_dates <- missing_dates[weekdays(missing_dates) %in% c("Monday","Tuesday","Friday","Saturday","Sunday")]

missing_dates <- missing_dates[order(lubridate::month(missing_dates),day(missing_dates))]
```

```{r}
dates_in_data <- unique(data$SeriesInd)

data_gathered_fill_in_missing <- data_gathered[,c("SeriesInd","group","Variable","Value","Group.plus.var")]

for(var in unique(data_gathered$Group.plus.var)[order(unique(data_gathered$Group.plus.var))])
{
data_this_var <- data_gathered[data_gathered$Group.plus.var == var,]

to_fill_in <- c()

for(date in as.Date(missing_dates,origin="1970-01-01"))
{
	this_nearest_before <- dates_in_data[dates_in_data < date]
	this_nearest_after <- dates_in_data[dates_in_data > date]
	to_fill_in <- c(to_fill_in,
		mean(c(data_this_var[data_this_var$SeriesInd == this_nearest_before[length(this_nearest_before)],"Value"],
		data_this_var[data_this_var$SeriesInd == this_nearest_after[1],"Value"])))
}

data_gathered_fill_in_missing <- rbind(data_gathered_fill_in_missing,
	data.frame(SeriesInd = as.Date(missing_dates,origin="1970-01-01"),
		group = unique(data_this_var$group),
		Variable = unique(data_this_var$Variable),
		Value = to_fill_in,
		Group.plus.var = var,
		stringsAsFactors=FALSE))
}
```

```{r}
data_gathered_fill_in_missing <- data_gathered_fill_in_missing[order(data_gathered_fill_in_missing$SeriesInd),]
```

```{r}
for(var in unique(data_gathered_fill_in_missing$Group.plus.var)[order(unique(data_gathered_fill_in_missing$Group.plus.var))])
{
data_this_var <- data_gathered_fill_in_missing[data_gathered_fill_in_missing$Group.plus.var == var,]

dates_in_data <- data_this_var$SeriesInd[which(is.na(data_this_var$Value) == FALSE)]

to_fill_in <- c()

for(date in data_this_var$SeriesInd[which(is.na(data_this_var$Value) == TRUE)])
{
	this_nearest_before <- dates_in_data[dates_in_data < date]
	this_nearest_after <- dates_in_data[dates_in_data > date]
	to_fill_in <- c(to_fill_in,
		mean(c(data_this_var[data_this_var$SeriesInd == this_nearest_before[length(this_nearest_before)],"Value"],
		data_this_var[data_this_var$SeriesInd == this_nearest_after[1],"Value"])))
}

data_gathered_fill_in_missing[which(is.na(data_gathered_fill_in_missing$Value) == TRUE & data_gathered_fill_in_missing$Group.plus.var == var),"Value"] <- to_fill_in
}
```

```{r}
data_gathered_fill_in_missing <- data_gathered_fill_in_missing[order(data_gathered_fill_in_missing$SeriesInd),]
```

### Dealing with missing Wednesdays and Thursdays

Fill in Wednesdays with a weighted average of 2/3 Tuesday + 1/3 Friday.

Fill in Thursdays with a weighted average of 1/3 Tuesday + 2/3 Friday.

```{r}
dates_in_data <- unique(data_gathered_fill_in_missing$SeriesInd)

tuesday_dates <- as.Date(dates_in_data[weekdays(dates_in_data) == "Tuesday"],origin="1970-01-01")

for(var in unique(data_gathered_fill_in_missing$Group.plus.var)[order(unique(data_gathered_fill_in_missing$Group.plus.var))])
{
data_this_var <- data_gathered_fill_in_missing[data_gathered_fill_in_missing$Group.plus.var == var,]

wednesday_values <- c()
thursday_values <- c()

for(date in tuesday_dates)
{ 
	tuesday_value = data_this_var$Value[data_this_var$SeriesInd == date]
	friday_date = as.Date(date + 3,origin = "1970-01-01")
	friday_value = data_this_var$Value[data_this_var$SeriesInd == friday_date]	

	wednesday_value = (((2/3)*tuesday_value) + ((1/3)*friday_value))
	thursday_value = (((1/3)*tuesday_value) + ((2/3)*friday_value))

	wednesday_values <- c(wednesday_values,wednesday_value)
	thursday_values <- c(thursday_values,thursday_value)
}

data_gathered_fill_in_missing <- rbind(data_gathered_fill_in_missing,
	data.frame(SeriesInd = as.Date(c(tuesday_dates + 1,tuesday_dates + 2),origin="1970-01-01"),
	group = unique(data_this_var$group),
	Variable = unique(data_this_var$Variable),
	Value = c(wednesday_values,thursday_values),
	Group.plus.var = var,
	stringsAsFactors=FALSE))
}
```

```{r}
data_gathered_fill_in_missing <- data_gathered_fill_in_missing[order(data_gathered_fill_in_missing$SeriesInd),]
```

### Check filled-in data.

Make sure we filled everything in correctly by re-plot data.

```{r}
outliers <- which(data_gathered_fill_in_missing$Group.plus.var == "S02-Var02" & data_gathered_fill_in_missing$Value > 3e8)
outliers <- c(outliers,which(data_gathered_fill_in_missing$Group.plus.var == "S02-Var03" & data_gathered_fill_in_missing$Value > 20))
outliers <- c(outliers,which(data_gathered_fill_in_missing$Group.plus.var == "S04-Var02" & data_gathered_fill_in_missing$Value > 1e8))

data_gathered_fill_in_missing_minus_outliers <- data_gathered_fill_in_missing[setdiff(1:nrow(data_gathered_fill_in_missing),outliers),]
```

```{r,fig.width=10,fig.height=6}
ggplot(data_gathered_fill_in_missing_minus_outliers,
aes(SeriesInd,Value)) +
geom_line() +
facet_wrap(~Group.plus.var,ncol=3,nrow=2,scales="free") +
xlab("Time") +
ggtitle("Minus outliers")
```

And check SeriesInd vs. range of possible dates.

```{r,echo=FALSE}
print("Number of dates now:")
```

```{r}
length(unique(data_gathered_fill_in_missing$SeriesInd))
```

```{r,echo=FALSE}
print("Range of dates from min to max:")
```

```{r}
length(seq(from = min(data_gathered_fill_in_missing$SeriesInd),to = max(data_gathered_fill_in_missing$SeriesInd),by="days"))
```

```{r, echo=FALSE}
save(data_gathered_fill_in_missing,
	file="data_gathered_fill_in_missing.Rdata")
```

### Deal with outliers.

Let's make a histogram of each variable, and use that to determine what should be considered outliers.

```{r}
for(var in unique(data_gathered_fill_in_missing$Group.plus.var)[order(unique(data_gathered_fill_in_missing$Group.plus.var))])
{
hist(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == var],
xlab="Values",
ylab="Dates",
main=var,
labels=TRUE)
}
```

Print data for outliers in S02-Var03.

```{r}
data_gathered_fill_in_missing[which(data_gathered_fill_in_missing$Value > 20 & data_gathered_fill_in_missing$Group.plus.var == "S02-Var03"),]
```

Looks like the outlier got magnified because it was also used to inform the nearby Wednesday and Thursday.

We'll have to fix this.

Try plotting log10 values for Var02.

```{r}
var = "S02-Var02"

hist(log10(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == var]),
xlab="log10(values)",
ylab="Dates",
main=var,
labels=TRUE)

var = "S04-Var02"

hist(log10(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == var]),
xlab="log10(values)",
ylab="Dates",
main=var,
labels=TRUE)
```

Looks like this looks much better! Should use log10 for both Var02 variables.

Other than that, I don't think skew or outliers are that big a deal. S04-Var01 seems to have a bit of right skew, but I don't think bad enough to run any transforms.

Let's reduce the point for 2017-08-04 down to only 3.5 SD above the mean.

Then calculate Wednesday and Thursday the usual way from there.

```{r}
S02_Var03_dat <- data_gathered_fill_in_missing[data_gathered_fill_in_missing$Group.plus.var == "S02-Var03",]
S02_Var03 <- S02_Var03_dat$Value
new_friday_value <- mean(S02_Var03[S02_Var03 < 20]) + 3.5*sd(S02_Var03[S02_Var03 < 20])
new_tuesday_value <- 13.05
wednesday_value = (((2/3)*new_tuesday_value) + ((1/3)*new_friday_value))
thursday_value = (((1/3)*new_tuesday_value) + ((2/3)*new_friday_value))

data_gathered_fill_in_missing[which(data_gathered_fill_in_missing$Group.plus.var == "S02-Var03")[2281:2283],"Value"] <- c(wednesday_value,thursday_value,new_friday_value)
```

Re-plot histogram.

```{r}
var = "S02-Var03"

hist(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == var],
xlab="Values",
ylab="Dates",
main=var,
labels=TRUE)
```														

### Create time series.

Create a time series for each of the six variables.

What I would really like to do is adjust the frequency argument to allow for auto detection of monthly seasonality. But since the length of a month varies, there is no easy way to do this, according to this resource: https://robjhyndman.com/hyndsight/seasonal-periods/.

So for now, just make a regular daily time series.

Use log10 for both Var02 series.

```{r}
S02_Var02 <- ts(log10(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == "S02-Var02"]),
	start = c(2011,126),
	frequency = 365.25)
```

```{r}
S02_Var03 <- ts(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == "S02-Var03"],
	start = c(2011,126),
	frequency = 365.25)
```

```{r}
S03_Var05 <- ts(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == "S03-Var05"],
    start = c(2011,126),
    frequency = 365.25)
```

```{r}
S03_Var07 <- ts(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == "S03-Var07"],
    start = c(2011,126),
    frequency = 365.25)
```

```{r}
S04_Var01 <- ts(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == "S04-Var01"],
    start = c(2011,126),
    frequency = 365.25)
```

```{r}
S04_Var02 <- ts(log10(data_gathered_fill_in_missing$Value[data_gathered_fill_in_missing$Group.plus.var == "S04-Var02"]),
    start = c(2011,126),
    frequency = 365.25)
```

# Forecasting

## Auto ARIMA on each variable

### S02-Var02

Let's start with S02, Var02. Try with and without adding in month data. Exclude seasonal component otherwise.

Remember that this data was log10 transformed.

```{r arima-totally-nonseasonal}
S02_Var02_arima_completely_nonseasonal <- auto.arima(y=S02_Var02,
	seasonal=FALSE)
```

```{r arima-with-months}
months <- data.frame(Month = factor(lubridate::month(unique(data_gathered_fill_in_missing$SeriesInd))))

months <- model.matrix(~Month,data=months)

months <- months[,2:ncol(months)]

S02_Var02_arima_nonseasonal_but_with_months <- auto.arima(y=S02_Var02,
	xreg = months,
	seasonal=FALSE)
```

```{r, echo=FALSE}
save(list=c("S02_Var02_arima_completely_nonseasonal","S02_Var02_arima_nonseasonal_but_with_months"),
file="S02_Var02_arima.Rdata")
```

```{r, echo=FALSE}
print("S02, Var02 auto ARIMA, no seasonal component allowed, no month info included:")
```

```{r}
S02_Var02_arima_completely_nonseasonal
```

```{r, echo=FALSE}
print("S02, Var02 auto ARIMA, no seasonal component allowed, month info included:")
```

```{r}
S02_Var02_arima_nonseasonal_but_with_months
```

Just based on AIC, the models look nearly identical.

What do the residuals of each of these look like?

```{r}
residuals_to_plot <- data.frame(SeriesInd = rep(unique(data_gathered_fill_in_missing$SeriesInd),times=2),
	Residuals = c(residuals(S02_Var02_arima_completely_nonseasonal),residuals(S02_Var02_arima_nonseasonal_but_with_months)),
	Model = rep(c("Completely nonseasonal","With months"),each=length(unique(data_gathered_fill_in_missing$SeriesInd))))
```

```{r}
ggplot(residuals_to_plot,
aes(SeriesInd,Residuals)) +
geom_line() +
facet_wrap(~Model,nrow=2) +
ggtitle("S02-Var02\nARIMA residuals after log10 transform")
```

Residuals vs. time plots look nearly identical as well.

How does this compare to ETS?

```{r}
S02_Var02_ETS <- ets(y=S02_Var02)
```

```{r}
S02_Var02_ETS
```

AIC of ETS is much higher.

Let's compare histogram of residuals.

```{r,fig.width=10,fig.height=6}
par(mfrow=c(1,2))

hist(residuals(S02_Var02_arima_completely_nonseasonal),
xlab="Residuals",
ylab="Number of dates",
main="ARIMA non-seasonal",
labels=TRUE,
breaks=seq(from=-1,to=1,by=0.1))

hist(S02_Var02_ETS$fitted - S02_Var02,
xlab="Residuals",
ylab="Number of dates",
main="ETS",
labels=TRUE,
breaks=seq(from=-1,to=1,by=0.1))
```

```{r}
hist(abs(residuals(S02_Var02_arima_completely_nonseasonal)),
xlab="abs(residuals)",
ylab="Number of dates",
main="ARIMA non-seasonal",
labels=TRUE,
breaks=seq(from=0,to=1,by=0.1))

hist(abs(S02_Var02_ETS$fitted - S02_Var02),
xlab="abs(residuals)",
ylab="Number of dates",
main="ETS",
labels=TRUE,
breaks=seq(from=0,to=1,by=0.1))
```

And residuals vs. time.

```{r}
plot(unique(data_gathered_fill_in_missing$SeriesInd),
S02_Var02_ETS$fitted - S02_Var02,
xlab="Time",
ylab="Residuals",
main="ETS",
type="l")
```

No obvious correlation between residuals and time.

# Wrapping up for the night

Let's save our main object data_gathered_fill_in_missing in case teammates want to play around starting from there.

This has outlier adjustment and filling in missing dates.

It does not have Var02 in log10 format, so should do that before create any time series.

```{r}
save(data_gathered_fill_in_missing,
file="data_gathered_fill_in_missing.Rdata")
```
